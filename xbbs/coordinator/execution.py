# Coordinator-side execution state.
# Copyright (C) 2025  Arsen ArsenoviÄ‡ <arsen@managarm.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
An execution is an attempt to perform the steps needed to build a node of the task
graph.  They're uniquely identified by a random string.
"""

import asyncio
import datetime
import enum
import os
import secrets
import typing as T

from .build_state import set_exec_abnormally_failed, set_exec_failed, set_exec_success

if T.TYPE_CHECKING:
    from .project import Build


class ExecutionState(enum.Enum):
    """How far along is this execution?"""

    IN_QUEUE = "IN_QUEUE"
    """The execution was allocated and queued, but is waiting on execution."""
    RUNNING = "RUNNING"
    """The execution was sent out."""
    FAILED_ABNORMALLY = "FAILED_ABNORMALLY"
    """
    The execution failed abnormally.  This usually means worker death.

    Will be retried up to three times.
    """
    FAILED = "FAILED"
    """The execution failed 'normally', in the sense that the build failed."""
    SUCCEEDED = "SUCCEEDED"
    """The execution terminated successfully."""


class Execution:
    """
    State of one execution.
    """

    def __init__(
        self,
        log_file: T.IO[bytes],
        execution_id: str,
        build: "Build",
    ) -> None:
        self.log_file: T.Final = log_file
        """Where to write log messages"""
        self.execution_id = execution_id
        """ID of this execution."""
        self.build: T.Final = build
        """Where to send artifacts?"""
        self.done: T.Final = asyncio.Event()
        """Set when this execution finishes in some way."""
        self.state = ExecutionState.IN_QUEUE
        """Current execution state."""
        self.queue_time: T.Final = datetime.datetime.now(datetime.timezone.utc)
        """When this execution was enqueued."""
        self.received_artifacts = dict[str, str]()
        """
        A mapping, from artifact identifier to where it is stored.  Used to delay
        artifact depositing.
        """

    def _done(
        self,
        new_state: T.Literal[
            ExecutionState.FAILED_ABNORMALLY, ExecutionState.FAILED, ExecutionState.SUCCEEDED
        ],
    ) -> None:
        assert not self.done.is_set()
        self.state = new_state
        self.done_time = datetime.datetime.now(datetime.timezone.utc)
        self.log_file.close()
        self.done.set()

    def abnormally_fail(self) -> None:
        """Marks this execution as abnormally failed."""
        self._done(ExecutionState.FAILED_ABNORMALLY)

        # Write that to disk.
        set_exec_abnormally_failed(self.build.build_dir, self.execution_id, self.done_time)

    def fail(self, run_time: float) -> None:
        """Mark this execution as failed."""
        self._done(ExecutionState.FAILED)

        # Write that to disk.
        set_exec_failed(self.build.build_dir, self.execution_id, self.done_time, run_time)

    def success(self, run_time: float) -> None:
        """Mark this execution as successful."""
        self._done(ExecutionState.SUCCEEDED)

        # Write that to disk.
        set_exec_success(self.build.build_dir, self.execution_id, self.done_time, run_time)

    def clean_up_artifacts(self) -> None:
        """Remove received artifacts from the disk."""
        assert self.state == ExecutionState.FAILED_ABNORMALLY

        for artifact_file in self.received_artifacts.values():
            os.unlink(artifact_file)


def generate_execution_id() -> str:
    """
    Generates an execution ID, which is a URL-safe string of randomly generated bytes.
    """
    return secrets.token_urlsafe(16)
